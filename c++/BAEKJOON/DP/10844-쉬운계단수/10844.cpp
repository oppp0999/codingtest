/* 45656처럼 인접한 자리수가 1씩 차이나고, 0으로 시작하는 수는 없습니다.
문제를 조금 더 분석해 보면, 계단수가 되기 위해서는
1뒤에는 0, 9뒤에는 8. 즉, 뒤에 1개의 수만 추가될 수 있습니다.
2~8은 각각 (1,3), (2,4), (3,5), ... (7,9), 즉 뒤에 2개의 수가 추가될 수 있습니다.
이러한 특징을 이용하여 DP 배열을 선언해보면,
DP[A][B] = C
DP[이번의 끝 수][수의 길이] = A로 끝나며, 길이가 B인 계단수의 개수C로 선언할 수 있습니다. */

#include <iostream>
using namespace std;

#define MOD 1000000000

int N;
int dp[9][101];
int ans =0;

int main(){
    cin >> N;

    //1,2,3,4,5,6,7,8,9는 계단 수 , 0으로 끝나는 수는 없음
    for(int i=1; i<=9; i++){
        dp[i][1]= 1;
    }

    for(int i =2; i<=N; i++){
        for(int j=0; j<=9; j++){
            if(j==0){
                //길이가 i이고 0으로 끝나는 계단 수는 바로 전의 수가 1로 끝나는 것만 가능
                dp[j][i]=dp[1][i-1];
            }
            else if(j==9){
                //길이가 i이고 9로 끝나는 계단 수는 바로 전의 수가 8로 끝나는 것만 가능
                dp[j][i] = dp[8][i-1];
            }
            else{
                //2-8로 끝나는 수는 2 앞뒤
                dp[j][i] += dp[j-1][i-1];
                dp[j][i] += dp[j+1][i-1];
            }
            dp[j][i] %= MOD;
        }
    }

    for(int i=0; i<=9; i++){
        //0~9까지 끝나며, 길이가 N인 수를 모두 더해서 출력
        ans += dp[i][N];
        ans %=MOD;
    }
    cout << ans;
}


/*  dp 배열
 	0	1	2	3	4	5	6	7	8	9
1	0	1	1	1	1	1	1	1	1	1
2	1	1	2	2	2	2	2	2	2	1 */
